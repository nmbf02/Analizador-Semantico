Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list
Rule 2     stmt_list -> stmt stmt_list
Rule 3     stmt_list -> empty
Rule 4     stmt -> var_decl
Rule 5     stmt -> assign_stmt
Rule 6     stmt -> if_stmt
Rule 7     stmt -> while_stmt
Rule 8     stmt -> print_stmt
Rule 9     stmt -> func_call
Rule 10    stmt -> func_decl
Rule 11    stmt -> return_stmt
Rule 12    var_decl -> INT ID SEMI
Rule 13    var_decl -> STRING_TYPE ID SEMI
Rule 14    var_decl -> BOOL_TYPE ID SEMI
Rule 15    assign_stmt -> ID EQUALS expr SEMI
Rule 16    if_stmt -> IF LPAREN expr RPAREN block
Rule 17    if_stmt -> IF LPAREN expr RPAREN block ELSE block
Rule 18    while_stmt -> WHILE LPAREN expr RPAREN block
Rule 19    print_stmt -> PRINT LPAREN expr RPAREN SEMI
Rule 20    func_call -> ID LPAREN args RPAREN SEMI
Rule 21    func_decl -> type ID LPAREN params RPAREN block
Rule 22    return_stmt -> RETURN expr SEMI
Rule 23    block -> LBRACE stmt_list RBRACE
Rule 24    args -> expr COMMA args
Rule 25    args -> expr
Rule 26    args -> empty
Rule 27    params -> param COMMA params
Rule 28    params -> param
Rule 29    params -> empty
Rule 30    param -> type ID
Rule 31    type -> INT
Rule 32    type -> STRING_TYPE
Rule 33    type -> BOOL_TYPE
Rule 34    expr -> expr PLUS expr
Rule 35    expr -> expr MINUS expr
Rule 36    expr -> expr TIMES expr
Rule 37    expr -> expr DIVIDE expr
Rule 38    expr -> expr EQ expr
Rule 39    expr -> expr NEQ expr
Rule 40    expr -> expr LT expr
Rule 41    expr -> expr GT expr
Rule 42    expr -> expr AND expr
Rule 43    expr -> expr OR expr
Rule 44    expr -> LPAREN expr RPAREN
Rule 45    expr -> NUMBER
Rule 46    expr -> STRING
Rule 47    expr -> TRUE
Rule 48    expr -> FALSE
Rule 49    expr -> ID
Rule 50    empty -> <empty>

Terminals, with rules where they appear

AND                  : 42
BOOL                 : 
BOOL_TYPE            : 14 33
COMMA                : 24 27
DIVIDE               : 37
ELSE                 : 17
EQ                   : 38
EQUALS               : 15
FALSE                : 48
GT                   : 41
ID                   : 12 13 14 15 20 21 30 49
IF                   : 16 17
INT                  : 12 31
LBRACE               : 23
LPAREN               : 16 17 18 19 20 21 44
LT                   : 40
MINUS                : 35
NEQ                  : 39
NUMBER               : 45
OR                   : 43
PLUS                 : 34
PRINT                : 19
RBRACE               : 23
RETURN               : 22
RPAREN               : 16 17 18 19 20 21 44
SEMI                 : 12 13 14 15 19 20 22
STRING               : 46
STRING_TYPE          : 13 32
TIMES                : 36
TRUE                 : 47
WHILE                : 18
error                : 

Nonterminals, with rules where they appear

args                 : 20 24
assign_stmt          : 5
block                : 16 17 17 18 21
empty                : 3 26 29
expr                 : 15 16 17 18 19 22 24 25 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44
func_call            : 9
func_decl            : 10
if_stmt              : 6
param                : 27 28
params               : 21 27
print_stmt           : 8
program              : 0
return_stmt          : 11
stmt                 : 2
stmt_list            : 1 2 23
type                 : 21 30
var_decl             : 4
while_stmt           : 7

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . var_decl
    (5) stmt -> . assign_stmt
    (6) stmt -> . if_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . print_stmt
    (9) stmt -> . func_call
    (10) stmt -> . func_decl
    (11) stmt -> . return_stmt
    (50) empty -> .
    (12) var_decl -> . INT ID SEMI
    (13) var_decl -> . STRING_TYPE ID SEMI
    (14) var_decl -> . BOOL_TYPE ID SEMI
    (15) assign_stmt -> . ID EQUALS expr SEMI
    (16) if_stmt -> . IF LPAREN expr RPAREN block
    (17) if_stmt -> . IF LPAREN expr RPAREN block ELSE block
    (18) while_stmt -> . WHILE LPAREN expr RPAREN block
    (19) print_stmt -> . PRINT LPAREN expr RPAREN SEMI
    (20) func_call -> . ID LPAREN args RPAREN SEMI
    (21) func_decl -> . type ID LPAREN params RPAREN block
    (22) return_stmt -> . RETURN expr SEMI
    (31) type -> . INT
    (32) type -> . STRING_TYPE
    (33) type -> . BOOL_TYPE

    $end            reduce using rule 50 (empty -> .)
    INT             shift and go to state 13
    STRING_TYPE     shift and go to state 15
    BOOL_TYPE       shift and go to state 16
    ID              shift and go to state 14
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    PRINT           shift and go to state 19
    RETURN          shift and go to state 21

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    empty                          shift and go to state 4
    var_decl                       shift and go to state 5
    assign_stmt                    shift and go to state 6
    if_stmt                        shift and go to state 7
    while_stmt                     shift and go to state 8
    print_stmt                     shift and go to state 9
    func_call                      shift and go to state 10
    func_decl                      shift and go to state 11
    return_stmt                    shift and go to state 12
    type                           shift and go to state 20

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list .

    $end            reduce using rule 1 (program -> stmt_list .)


state 3

    (2) stmt_list -> stmt . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . var_decl
    (5) stmt -> . assign_stmt
    (6) stmt -> . if_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . print_stmt
    (9) stmt -> . func_call
    (10) stmt -> . func_decl
    (11) stmt -> . return_stmt
    (50) empty -> .
    (12) var_decl -> . INT ID SEMI
    (13) var_decl -> . STRING_TYPE ID SEMI
    (14) var_decl -> . BOOL_TYPE ID SEMI
    (15) assign_stmt -> . ID EQUALS expr SEMI
    (16) if_stmt -> . IF LPAREN expr RPAREN block
    (17) if_stmt -> . IF LPAREN expr RPAREN block ELSE block
    (18) while_stmt -> . WHILE LPAREN expr RPAREN block
    (19) print_stmt -> . PRINT LPAREN expr RPAREN SEMI
    (20) func_call -> . ID LPAREN args RPAREN SEMI
    (21) func_decl -> . type ID LPAREN params RPAREN block
    (22) return_stmt -> . RETURN expr SEMI
    (31) type -> . INT
    (32) type -> . STRING_TYPE
    (33) type -> . BOOL_TYPE

    $end            reduce using rule 50 (empty -> .)
    RBRACE          reduce using rule 50 (empty -> .)
    INT             shift and go to state 13
    STRING_TYPE     shift and go to state 15
    BOOL_TYPE       shift and go to state 16
    ID              shift and go to state 14
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    PRINT           shift and go to state 19
    RETURN          shift and go to state 21

    stmt                           shift and go to state 3
    stmt_list                      shift and go to state 22
    empty                          shift and go to state 4
    var_decl                       shift and go to state 5
    assign_stmt                    shift and go to state 6
    if_stmt                        shift and go to state 7
    while_stmt                     shift and go to state 8
    print_stmt                     shift and go to state 9
    func_call                      shift and go to state 10
    func_decl                      shift and go to state 11
    return_stmt                    shift and go to state 12
    type                           shift and go to state 20

state 4

    (3) stmt_list -> empty .

    $end            reduce using rule 3 (stmt_list -> empty .)
    RBRACE          reduce using rule 3 (stmt_list -> empty .)


state 5

    (4) stmt -> var_decl .

    INT             reduce using rule 4 (stmt -> var_decl .)
    STRING_TYPE     reduce using rule 4 (stmt -> var_decl .)
    BOOL_TYPE       reduce using rule 4 (stmt -> var_decl .)
    ID              reduce using rule 4 (stmt -> var_decl .)
    IF              reduce using rule 4 (stmt -> var_decl .)
    WHILE           reduce using rule 4 (stmt -> var_decl .)
    PRINT           reduce using rule 4 (stmt -> var_decl .)
    RETURN          reduce using rule 4 (stmt -> var_decl .)
    $end            reduce using rule 4 (stmt -> var_decl .)
    RBRACE          reduce using rule 4 (stmt -> var_decl .)


state 6

    (5) stmt -> assign_stmt .

    INT             reduce using rule 5 (stmt -> assign_stmt .)
    STRING_TYPE     reduce using rule 5 (stmt -> assign_stmt .)
    BOOL_TYPE       reduce using rule 5 (stmt -> assign_stmt .)
    ID              reduce using rule 5 (stmt -> assign_stmt .)
    IF              reduce using rule 5 (stmt -> assign_stmt .)
    WHILE           reduce using rule 5 (stmt -> assign_stmt .)
    PRINT           reduce using rule 5 (stmt -> assign_stmt .)
    RETURN          reduce using rule 5 (stmt -> assign_stmt .)
    $end            reduce using rule 5 (stmt -> assign_stmt .)
    RBRACE          reduce using rule 5 (stmt -> assign_stmt .)


state 7

    (6) stmt -> if_stmt .

    INT             reduce using rule 6 (stmt -> if_stmt .)
    STRING_TYPE     reduce using rule 6 (stmt -> if_stmt .)
    BOOL_TYPE       reduce using rule 6 (stmt -> if_stmt .)
    ID              reduce using rule 6 (stmt -> if_stmt .)
    IF              reduce using rule 6 (stmt -> if_stmt .)
    WHILE           reduce using rule 6 (stmt -> if_stmt .)
    PRINT           reduce using rule 6 (stmt -> if_stmt .)
    RETURN          reduce using rule 6 (stmt -> if_stmt .)
    $end            reduce using rule 6 (stmt -> if_stmt .)
    RBRACE          reduce using rule 6 (stmt -> if_stmt .)


state 8

    (7) stmt -> while_stmt .

    INT             reduce using rule 7 (stmt -> while_stmt .)
    STRING_TYPE     reduce using rule 7 (stmt -> while_stmt .)
    BOOL_TYPE       reduce using rule 7 (stmt -> while_stmt .)
    ID              reduce using rule 7 (stmt -> while_stmt .)
    IF              reduce using rule 7 (stmt -> while_stmt .)
    WHILE           reduce using rule 7 (stmt -> while_stmt .)
    PRINT           reduce using rule 7 (stmt -> while_stmt .)
    RETURN          reduce using rule 7 (stmt -> while_stmt .)
    $end            reduce using rule 7 (stmt -> while_stmt .)
    RBRACE          reduce using rule 7 (stmt -> while_stmt .)


state 9

    (8) stmt -> print_stmt .

    INT             reduce using rule 8 (stmt -> print_stmt .)
    STRING_TYPE     reduce using rule 8 (stmt -> print_stmt .)
    BOOL_TYPE       reduce using rule 8 (stmt -> print_stmt .)
    ID              reduce using rule 8 (stmt -> print_stmt .)
    IF              reduce using rule 8 (stmt -> print_stmt .)
    WHILE           reduce using rule 8 (stmt -> print_stmt .)
    PRINT           reduce using rule 8 (stmt -> print_stmt .)
    RETURN          reduce using rule 8 (stmt -> print_stmt .)
    $end            reduce using rule 8 (stmt -> print_stmt .)
    RBRACE          reduce using rule 8 (stmt -> print_stmt .)


state 10

    (9) stmt -> func_call .

    INT             reduce using rule 9 (stmt -> func_call .)
    STRING_TYPE     reduce using rule 9 (stmt -> func_call .)
    BOOL_TYPE       reduce using rule 9 (stmt -> func_call .)
    ID              reduce using rule 9 (stmt -> func_call .)
    IF              reduce using rule 9 (stmt -> func_call .)
    WHILE           reduce using rule 9 (stmt -> func_call .)
    PRINT           reduce using rule 9 (stmt -> func_call .)
    RETURN          reduce using rule 9 (stmt -> func_call .)
    $end            reduce using rule 9 (stmt -> func_call .)
    RBRACE          reduce using rule 9 (stmt -> func_call .)


state 11

    (10) stmt -> func_decl .

    INT             reduce using rule 10 (stmt -> func_decl .)
    STRING_TYPE     reduce using rule 10 (stmt -> func_decl .)
    BOOL_TYPE       reduce using rule 10 (stmt -> func_decl .)
    ID              reduce using rule 10 (stmt -> func_decl .)
    IF              reduce using rule 10 (stmt -> func_decl .)
    WHILE           reduce using rule 10 (stmt -> func_decl .)
    PRINT           reduce using rule 10 (stmt -> func_decl .)
    RETURN          reduce using rule 10 (stmt -> func_decl .)
    $end            reduce using rule 10 (stmt -> func_decl .)
    RBRACE          reduce using rule 10 (stmt -> func_decl .)


state 12

    (11) stmt -> return_stmt .

    INT             reduce using rule 11 (stmt -> return_stmt .)
    STRING_TYPE     reduce using rule 11 (stmt -> return_stmt .)
    BOOL_TYPE       reduce using rule 11 (stmt -> return_stmt .)
    ID              reduce using rule 11 (stmt -> return_stmt .)
    IF              reduce using rule 11 (stmt -> return_stmt .)
    WHILE           reduce using rule 11 (stmt -> return_stmt .)
    PRINT           reduce using rule 11 (stmt -> return_stmt .)
    RETURN          reduce using rule 11 (stmt -> return_stmt .)
    $end            reduce using rule 11 (stmt -> return_stmt .)
    RBRACE          reduce using rule 11 (stmt -> return_stmt .)


state 13

    (12) var_decl -> INT . ID SEMI
    (31) type -> INT .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 23

  ! ID              [ reduce using rule 31 (type -> INT .) ]


state 14

    (15) assign_stmt -> ID . EQUALS expr SEMI
    (20) func_call -> ID . LPAREN args RPAREN SEMI

    EQUALS          shift and go to state 24
    LPAREN          shift and go to state 25


state 15

    (13) var_decl -> STRING_TYPE . ID SEMI
    (32) type -> STRING_TYPE .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 26

  ! ID              [ reduce using rule 32 (type -> STRING_TYPE .) ]


state 16

    (14) var_decl -> BOOL_TYPE . ID SEMI
    (33) type -> BOOL_TYPE .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 27

  ! ID              [ reduce using rule 33 (type -> BOOL_TYPE .) ]


state 17

    (16) if_stmt -> IF . LPAREN expr RPAREN block
    (17) if_stmt -> IF . LPAREN expr RPAREN block ELSE block

    LPAREN          shift and go to state 28


state 18

    (18) while_stmt -> WHILE . LPAREN expr RPAREN block

    LPAREN          shift and go to state 29


state 19

    (19) print_stmt -> PRINT . LPAREN expr RPAREN SEMI

    LPAREN          shift and go to state 30


state 20

    (21) func_decl -> type . ID LPAREN params RPAREN block

    ID              shift and go to state 31


state 21

    (22) return_stmt -> RETURN . expr SEMI
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 32

state 22

    (2) stmt_list -> stmt stmt_list .

    $end            reduce using rule 2 (stmt_list -> stmt stmt_list .)
    RBRACE          reduce using rule 2 (stmt_list -> stmt stmt_list .)


state 23

    (12) var_decl -> INT ID . SEMI

    SEMI            shift and go to state 39


state 24

    (15) assign_stmt -> ID EQUALS . expr SEMI
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 40

state 25

    (20) func_call -> ID LPAREN . args RPAREN SEMI
    (24) args -> . expr COMMA args
    (25) args -> . expr
    (26) args -> . empty
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID
    (50) empty -> .

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38
    RPAREN          reduce using rule 50 (empty -> .)

    args                           shift and go to state 41
    expr                           shift and go to state 42
    empty                          shift and go to state 43

state 26

    (13) var_decl -> STRING_TYPE ID . SEMI

    SEMI            shift and go to state 44


state 27

    (14) var_decl -> BOOL_TYPE ID . SEMI

    SEMI            shift and go to state 45


state 28

    (16) if_stmt -> IF LPAREN . expr RPAREN block
    (17) if_stmt -> IF LPAREN . expr RPAREN block ELSE block
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 46

state 29

    (18) while_stmt -> WHILE LPAREN . expr RPAREN block
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 47

state 30

    (19) print_stmt -> PRINT LPAREN . expr RPAREN SEMI
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 48

state 31

    (21) func_decl -> type ID . LPAREN params RPAREN block

    LPAREN          shift and go to state 49


state 32

    (22) return_stmt -> RETURN expr . SEMI
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    SEMI            shift and go to state 50
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    AND             shift and go to state 59
    OR              shift and go to state 60


state 33

    (44) expr -> LPAREN . expr RPAREN
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 61

state 34

    (45) expr -> NUMBER .

    SEMI            reduce using rule 45 (expr -> NUMBER .)
    PLUS            reduce using rule 45 (expr -> NUMBER .)
    MINUS           reduce using rule 45 (expr -> NUMBER .)
    TIMES           reduce using rule 45 (expr -> NUMBER .)
    DIVIDE          reduce using rule 45 (expr -> NUMBER .)
    EQ              reduce using rule 45 (expr -> NUMBER .)
    NEQ             reduce using rule 45 (expr -> NUMBER .)
    LT              reduce using rule 45 (expr -> NUMBER .)
    GT              reduce using rule 45 (expr -> NUMBER .)
    AND             reduce using rule 45 (expr -> NUMBER .)
    OR              reduce using rule 45 (expr -> NUMBER .)
    COMMA           reduce using rule 45 (expr -> NUMBER .)
    RPAREN          reduce using rule 45 (expr -> NUMBER .)


state 35

    (46) expr -> STRING .

    SEMI            reduce using rule 46 (expr -> STRING .)
    PLUS            reduce using rule 46 (expr -> STRING .)
    MINUS           reduce using rule 46 (expr -> STRING .)
    TIMES           reduce using rule 46 (expr -> STRING .)
    DIVIDE          reduce using rule 46 (expr -> STRING .)
    EQ              reduce using rule 46 (expr -> STRING .)
    NEQ             reduce using rule 46 (expr -> STRING .)
    LT              reduce using rule 46 (expr -> STRING .)
    GT              reduce using rule 46 (expr -> STRING .)
    AND             reduce using rule 46 (expr -> STRING .)
    OR              reduce using rule 46 (expr -> STRING .)
    COMMA           reduce using rule 46 (expr -> STRING .)
    RPAREN          reduce using rule 46 (expr -> STRING .)


state 36

    (47) expr -> TRUE .

    SEMI            reduce using rule 47 (expr -> TRUE .)
    PLUS            reduce using rule 47 (expr -> TRUE .)
    MINUS           reduce using rule 47 (expr -> TRUE .)
    TIMES           reduce using rule 47 (expr -> TRUE .)
    DIVIDE          reduce using rule 47 (expr -> TRUE .)
    EQ              reduce using rule 47 (expr -> TRUE .)
    NEQ             reduce using rule 47 (expr -> TRUE .)
    LT              reduce using rule 47 (expr -> TRUE .)
    GT              reduce using rule 47 (expr -> TRUE .)
    AND             reduce using rule 47 (expr -> TRUE .)
    OR              reduce using rule 47 (expr -> TRUE .)
    COMMA           reduce using rule 47 (expr -> TRUE .)
    RPAREN          reduce using rule 47 (expr -> TRUE .)


state 37

    (48) expr -> FALSE .

    SEMI            reduce using rule 48 (expr -> FALSE .)
    PLUS            reduce using rule 48 (expr -> FALSE .)
    MINUS           reduce using rule 48 (expr -> FALSE .)
    TIMES           reduce using rule 48 (expr -> FALSE .)
    DIVIDE          reduce using rule 48 (expr -> FALSE .)
    EQ              reduce using rule 48 (expr -> FALSE .)
    NEQ             reduce using rule 48 (expr -> FALSE .)
    LT              reduce using rule 48 (expr -> FALSE .)
    GT              reduce using rule 48 (expr -> FALSE .)
    AND             reduce using rule 48 (expr -> FALSE .)
    OR              reduce using rule 48 (expr -> FALSE .)
    COMMA           reduce using rule 48 (expr -> FALSE .)
    RPAREN          reduce using rule 48 (expr -> FALSE .)


state 38

    (49) expr -> ID .

    SEMI            reduce using rule 49 (expr -> ID .)
    PLUS            reduce using rule 49 (expr -> ID .)
    MINUS           reduce using rule 49 (expr -> ID .)
    TIMES           reduce using rule 49 (expr -> ID .)
    DIVIDE          reduce using rule 49 (expr -> ID .)
    EQ              reduce using rule 49 (expr -> ID .)
    NEQ             reduce using rule 49 (expr -> ID .)
    LT              reduce using rule 49 (expr -> ID .)
    GT              reduce using rule 49 (expr -> ID .)
    AND             reduce using rule 49 (expr -> ID .)
    OR              reduce using rule 49 (expr -> ID .)
    COMMA           reduce using rule 49 (expr -> ID .)
    RPAREN          reduce using rule 49 (expr -> ID .)


state 39

    (12) var_decl -> INT ID SEMI .

    INT             reduce using rule 12 (var_decl -> INT ID SEMI .)
    STRING_TYPE     reduce using rule 12 (var_decl -> INT ID SEMI .)
    BOOL_TYPE       reduce using rule 12 (var_decl -> INT ID SEMI .)
    ID              reduce using rule 12 (var_decl -> INT ID SEMI .)
    IF              reduce using rule 12 (var_decl -> INT ID SEMI .)
    WHILE           reduce using rule 12 (var_decl -> INT ID SEMI .)
    PRINT           reduce using rule 12 (var_decl -> INT ID SEMI .)
    RETURN          reduce using rule 12 (var_decl -> INT ID SEMI .)
    $end            reduce using rule 12 (var_decl -> INT ID SEMI .)
    RBRACE          reduce using rule 12 (var_decl -> INT ID SEMI .)


state 40

    (15) assign_stmt -> ID EQUALS expr . SEMI
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    SEMI            shift and go to state 62
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    AND             shift and go to state 59
    OR              shift and go to state 60


state 41

    (20) func_call -> ID LPAREN args . RPAREN SEMI

    RPAREN          shift and go to state 63


state 42

    (24) args -> expr . COMMA args
    (25) args -> expr .
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    COMMA           shift and go to state 64
    RPAREN          reduce using rule 25 (args -> expr .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    AND             shift and go to state 59
    OR              shift and go to state 60


state 43

    (26) args -> empty .

    RPAREN          reduce using rule 26 (args -> empty .)


state 44

    (13) var_decl -> STRING_TYPE ID SEMI .

    INT             reduce using rule 13 (var_decl -> STRING_TYPE ID SEMI .)
    STRING_TYPE     reduce using rule 13 (var_decl -> STRING_TYPE ID SEMI .)
    BOOL_TYPE       reduce using rule 13 (var_decl -> STRING_TYPE ID SEMI .)
    ID              reduce using rule 13 (var_decl -> STRING_TYPE ID SEMI .)
    IF              reduce using rule 13 (var_decl -> STRING_TYPE ID SEMI .)
    WHILE           reduce using rule 13 (var_decl -> STRING_TYPE ID SEMI .)
    PRINT           reduce using rule 13 (var_decl -> STRING_TYPE ID SEMI .)
    RETURN          reduce using rule 13 (var_decl -> STRING_TYPE ID SEMI .)
    $end            reduce using rule 13 (var_decl -> STRING_TYPE ID SEMI .)
    RBRACE          reduce using rule 13 (var_decl -> STRING_TYPE ID SEMI .)


state 45

    (14) var_decl -> BOOL_TYPE ID SEMI .

    INT             reduce using rule 14 (var_decl -> BOOL_TYPE ID SEMI .)
    STRING_TYPE     reduce using rule 14 (var_decl -> BOOL_TYPE ID SEMI .)
    BOOL_TYPE       reduce using rule 14 (var_decl -> BOOL_TYPE ID SEMI .)
    ID              reduce using rule 14 (var_decl -> BOOL_TYPE ID SEMI .)
    IF              reduce using rule 14 (var_decl -> BOOL_TYPE ID SEMI .)
    WHILE           reduce using rule 14 (var_decl -> BOOL_TYPE ID SEMI .)
    PRINT           reduce using rule 14 (var_decl -> BOOL_TYPE ID SEMI .)
    RETURN          reduce using rule 14 (var_decl -> BOOL_TYPE ID SEMI .)
    $end            reduce using rule 14 (var_decl -> BOOL_TYPE ID SEMI .)
    RBRACE          reduce using rule 14 (var_decl -> BOOL_TYPE ID SEMI .)


state 46

    (16) if_stmt -> IF LPAREN expr . RPAREN block
    (17) if_stmt -> IF LPAREN expr . RPAREN block ELSE block
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    RPAREN          shift and go to state 65
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    AND             shift and go to state 59
    OR              shift and go to state 60


state 47

    (18) while_stmt -> WHILE LPAREN expr . RPAREN block
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    RPAREN          shift and go to state 66
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    AND             shift and go to state 59
    OR              shift and go to state 60


state 48

    (19) print_stmt -> PRINT LPAREN expr . RPAREN SEMI
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    RPAREN          shift and go to state 67
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    AND             shift and go to state 59
    OR              shift and go to state 60


state 49

    (21) func_decl -> type ID LPAREN . params RPAREN block
    (27) params -> . param COMMA params
    (28) params -> . param
    (29) params -> . empty
    (30) param -> . type ID
    (50) empty -> .
    (31) type -> . INT
    (32) type -> . STRING_TYPE
    (33) type -> . BOOL_TYPE

    RPAREN          reduce using rule 50 (empty -> .)
    INT             shift and go to state 72
    STRING_TYPE     shift and go to state 73
    BOOL_TYPE       shift and go to state 74

    type                           shift and go to state 68
    params                         shift and go to state 69
    param                          shift and go to state 70
    empty                          shift and go to state 71

state 50

    (22) return_stmt -> RETURN expr SEMI .

    INT             reduce using rule 22 (return_stmt -> RETURN expr SEMI .)
    STRING_TYPE     reduce using rule 22 (return_stmt -> RETURN expr SEMI .)
    BOOL_TYPE       reduce using rule 22 (return_stmt -> RETURN expr SEMI .)
    ID              reduce using rule 22 (return_stmt -> RETURN expr SEMI .)
    IF              reduce using rule 22 (return_stmt -> RETURN expr SEMI .)
    WHILE           reduce using rule 22 (return_stmt -> RETURN expr SEMI .)
    PRINT           reduce using rule 22 (return_stmt -> RETURN expr SEMI .)
    RETURN          reduce using rule 22 (return_stmt -> RETURN expr SEMI .)
    $end            reduce using rule 22 (return_stmt -> RETURN expr SEMI .)
    RBRACE          reduce using rule 22 (return_stmt -> RETURN expr SEMI .)


state 51

    (34) expr -> expr PLUS . expr
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 75

state 52

    (35) expr -> expr MINUS . expr
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 76

state 53

    (36) expr -> expr TIMES . expr
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 77

state 54

    (37) expr -> expr DIVIDE . expr
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 78

state 55

    (38) expr -> expr EQ . expr
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 79

state 56

    (39) expr -> expr NEQ . expr
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 80

state 57

    (40) expr -> expr LT . expr
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 81

state 58

    (41) expr -> expr GT . expr
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 82

state 59

    (42) expr -> expr AND . expr
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 83

state 60

    (43) expr -> expr OR . expr
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38

    expr                           shift and go to state 84

state 61

    (44) expr -> LPAREN expr . RPAREN
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    RPAREN          shift and go to state 85
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    AND             shift and go to state 59
    OR              shift and go to state 60


state 62

    (15) assign_stmt -> ID EQUALS expr SEMI .

    INT             reduce using rule 15 (assign_stmt -> ID EQUALS expr SEMI .)
    STRING_TYPE     reduce using rule 15 (assign_stmt -> ID EQUALS expr SEMI .)
    BOOL_TYPE       reduce using rule 15 (assign_stmt -> ID EQUALS expr SEMI .)
    ID              reduce using rule 15 (assign_stmt -> ID EQUALS expr SEMI .)
    IF              reduce using rule 15 (assign_stmt -> ID EQUALS expr SEMI .)
    WHILE           reduce using rule 15 (assign_stmt -> ID EQUALS expr SEMI .)
    PRINT           reduce using rule 15 (assign_stmt -> ID EQUALS expr SEMI .)
    RETURN          reduce using rule 15 (assign_stmt -> ID EQUALS expr SEMI .)
    $end            reduce using rule 15 (assign_stmt -> ID EQUALS expr SEMI .)
    RBRACE          reduce using rule 15 (assign_stmt -> ID EQUALS expr SEMI .)


state 63

    (20) func_call -> ID LPAREN args RPAREN . SEMI

    SEMI            shift and go to state 86


state 64

    (24) args -> expr COMMA . args
    (24) args -> . expr COMMA args
    (25) args -> . expr
    (26) args -> . empty
    (34) expr -> . expr PLUS expr
    (35) expr -> . expr MINUS expr
    (36) expr -> . expr TIMES expr
    (37) expr -> . expr DIVIDE expr
    (38) expr -> . expr EQ expr
    (39) expr -> . expr NEQ expr
    (40) expr -> . expr LT expr
    (41) expr -> . expr GT expr
    (42) expr -> . expr AND expr
    (43) expr -> . expr OR expr
    (44) expr -> . LPAREN expr RPAREN
    (45) expr -> . NUMBER
    (46) expr -> . STRING
    (47) expr -> . TRUE
    (48) expr -> . FALSE
    (49) expr -> . ID
    (50) empty -> .

    LPAREN          shift and go to state 33
    NUMBER          shift and go to state 34
    STRING          shift and go to state 35
    TRUE            shift and go to state 36
    FALSE           shift and go to state 37
    ID              shift and go to state 38
    RPAREN          reduce using rule 50 (empty -> .)

    expr                           shift and go to state 42
    args                           shift and go to state 87
    empty                          shift and go to state 43

state 65

    (16) if_stmt -> IF LPAREN expr RPAREN . block
    (17) if_stmt -> IF LPAREN expr RPAREN . block ELSE block
    (23) block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 89

    block                          shift and go to state 88

state 66

    (18) while_stmt -> WHILE LPAREN expr RPAREN . block
    (23) block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 89

    block                          shift and go to state 90

state 67

    (19) print_stmt -> PRINT LPAREN expr RPAREN . SEMI

    SEMI            shift and go to state 91


state 68

    (30) param -> type . ID

    ID              shift and go to state 92


state 69

    (21) func_decl -> type ID LPAREN params . RPAREN block

    RPAREN          shift and go to state 93


state 70

    (27) params -> param . COMMA params
    (28) params -> param .

    COMMA           shift and go to state 94
    RPAREN          reduce using rule 28 (params -> param .)


state 71

    (29) params -> empty .

    RPAREN          reduce using rule 29 (params -> empty .)


state 72

    (31) type -> INT .

    ID              reduce using rule 31 (type -> INT .)


state 73

    (32) type -> STRING_TYPE .

    ID              reduce using rule 32 (type -> STRING_TYPE .)


state 74

    (33) type -> BOOL_TYPE .

    ID              reduce using rule 33 (type -> BOOL_TYPE .)


state 75

    (34) expr -> expr PLUS expr .
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    SEMI            reduce using rule 34 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 34 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 34 (expr -> expr PLUS expr .)
    EQ              reduce using rule 34 (expr -> expr PLUS expr .)
    NEQ             reduce using rule 34 (expr -> expr PLUS expr .)
    LT              reduce using rule 34 (expr -> expr PLUS expr .)
    GT              reduce using rule 34 (expr -> expr PLUS expr .)
    AND             reduce using rule 34 (expr -> expr PLUS expr .)
    OR              reduce using rule 34 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 34 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 34 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54

  ! TIMES           [ reduce using rule 34 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 34 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 60 ]


state 76

    (35) expr -> expr MINUS expr .
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    SEMI            reduce using rule 35 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 35 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 35 (expr -> expr MINUS expr .)
    EQ              reduce using rule 35 (expr -> expr MINUS expr .)
    NEQ             reduce using rule 35 (expr -> expr MINUS expr .)
    LT              reduce using rule 35 (expr -> expr MINUS expr .)
    GT              reduce using rule 35 (expr -> expr MINUS expr .)
    AND             reduce using rule 35 (expr -> expr MINUS expr .)
    OR              reduce using rule 35 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 35 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 35 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54

  ! TIMES           [ reduce using rule 35 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 35 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 60 ]


state 77

    (36) expr -> expr TIMES expr .
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    SEMI            reduce using rule 36 (expr -> expr TIMES expr .)
    PLUS            reduce using rule 36 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 36 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 36 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 36 (expr -> expr TIMES expr .)
    EQ              reduce using rule 36 (expr -> expr TIMES expr .)
    NEQ             reduce using rule 36 (expr -> expr TIMES expr .)
    LT              reduce using rule 36 (expr -> expr TIMES expr .)
    GT              reduce using rule 36 (expr -> expr TIMES expr .)
    AND             reduce using rule 36 (expr -> expr TIMES expr .)
    OR              reduce using rule 36 (expr -> expr TIMES expr .)
    COMMA           reduce using rule 36 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 36 (expr -> expr TIMES expr .)

  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 53 ]
  ! DIVIDE          [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 60 ]


state 78

    (37) expr -> expr DIVIDE expr .
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    SEMI            reduce using rule 37 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 37 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 37 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 37 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 37 (expr -> expr DIVIDE expr .)
    EQ              reduce using rule 37 (expr -> expr DIVIDE expr .)
    NEQ             reduce using rule 37 (expr -> expr DIVIDE expr .)
    LT              reduce using rule 37 (expr -> expr DIVIDE expr .)
    GT              reduce using rule 37 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 37 (expr -> expr DIVIDE expr .)
    OR              reduce using rule 37 (expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 37 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 37 (expr -> expr DIVIDE expr .)

  ! PLUS            [ shift and go to state 51 ]
  ! MINUS           [ shift and go to state 52 ]
  ! TIMES           [ shift and go to state 53 ]
  ! DIVIDE          [ shift and go to state 54 ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 60 ]


state 79

    (38) expr -> expr EQ expr .
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    SEMI            reduce using rule 38 (expr -> expr EQ expr .)
    EQ              reduce using rule 38 (expr -> expr EQ expr .)
    NEQ             reduce using rule 38 (expr -> expr EQ expr .)
    AND             reduce using rule 38 (expr -> expr EQ expr .)
    OR              reduce using rule 38 (expr -> expr EQ expr .)
    COMMA           reduce using rule 38 (expr -> expr EQ expr .)
    RPAREN          reduce using rule 38 (expr -> expr EQ expr .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    LT              shift and go to state 57
    GT              shift and go to state 58

  ! PLUS            [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! MINUS           [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! TIMES           [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! DIVIDE          [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! LT              [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! GT              [ reduce using rule 38 (expr -> expr EQ expr .) ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 60 ]


state 80

    (39) expr -> expr NEQ expr .
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    SEMI            reduce using rule 39 (expr -> expr NEQ expr .)
    EQ              reduce using rule 39 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 39 (expr -> expr NEQ expr .)
    AND             reduce using rule 39 (expr -> expr NEQ expr .)
    OR              reduce using rule 39 (expr -> expr NEQ expr .)
    COMMA           reduce using rule 39 (expr -> expr NEQ expr .)
    RPAREN          reduce using rule 39 (expr -> expr NEQ expr .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    LT              shift and go to state 57
    GT              shift and go to state 58

  ! PLUS            [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! MINUS           [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! TIMES           [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! DIVIDE          [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! LT              [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! GT              [ reduce using rule 39 (expr -> expr NEQ expr .) ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 60 ]


state 81

    (40) expr -> expr LT expr .
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    SEMI            reduce using rule 40 (expr -> expr LT expr .)
    EQ              reduce using rule 40 (expr -> expr LT expr .)
    NEQ             reduce using rule 40 (expr -> expr LT expr .)
    LT              reduce using rule 40 (expr -> expr LT expr .)
    GT              reduce using rule 40 (expr -> expr LT expr .)
    AND             reduce using rule 40 (expr -> expr LT expr .)
    OR              reduce using rule 40 (expr -> expr LT expr .)
    COMMA           reduce using rule 40 (expr -> expr LT expr .)
    RPAREN          reduce using rule 40 (expr -> expr LT expr .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54

  ! PLUS            [ reduce using rule 40 (expr -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 40 (expr -> expr LT expr .) ]
  ! TIMES           [ reduce using rule 40 (expr -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 40 (expr -> expr LT expr .) ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 60 ]


state 82

    (41) expr -> expr GT expr .
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    SEMI            reduce using rule 41 (expr -> expr GT expr .)
    EQ              reduce using rule 41 (expr -> expr GT expr .)
    NEQ             reduce using rule 41 (expr -> expr GT expr .)
    LT              reduce using rule 41 (expr -> expr GT expr .)
    GT              reduce using rule 41 (expr -> expr GT expr .)
    AND             reduce using rule 41 (expr -> expr GT expr .)
    OR              reduce using rule 41 (expr -> expr GT expr .)
    COMMA           reduce using rule 41 (expr -> expr GT expr .)
    RPAREN          reduce using rule 41 (expr -> expr GT expr .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54

  ! PLUS            [ reduce using rule 41 (expr -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 41 (expr -> expr GT expr .) ]
  ! TIMES           [ reduce using rule 41 (expr -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 41 (expr -> expr GT expr .) ]
  ! EQ              [ shift and go to state 55 ]
  ! NEQ             [ shift and go to state 56 ]
  ! LT              [ shift and go to state 57 ]
  ! GT              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 60 ]


state 83

    (42) expr -> expr AND expr .
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    SEMI            reduce using rule 42 (expr -> expr AND expr .)
    AND             reduce using rule 42 (expr -> expr AND expr .)
    OR              reduce using rule 42 (expr -> expr AND expr .)
    COMMA           reduce using rule 42 (expr -> expr AND expr .)
    RPAREN          reduce using rule 42 (expr -> expr AND expr .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58

  ! PLUS            [ reduce using rule 42 (expr -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 42 (expr -> expr AND expr .) ]
  ! TIMES           [ reduce using rule 42 (expr -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 42 (expr -> expr AND expr .) ]
  ! EQ              [ reduce using rule 42 (expr -> expr AND expr .) ]
  ! NEQ             [ reduce using rule 42 (expr -> expr AND expr .) ]
  ! LT              [ reduce using rule 42 (expr -> expr AND expr .) ]
  ! GT              [ reduce using rule 42 (expr -> expr AND expr .) ]
  ! AND             [ shift and go to state 59 ]
  ! OR              [ shift and go to state 60 ]


state 84

    (43) expr -> expr OR expr .
    (34) expr -> expr . PLUS expr
    (35) expr -> expr . MINUS expr
    (36) expr -> expr . TIMES expr
    (37) expr -> expr . DIVIDE expr
    (38) expr -> expr . EQ expr
    (39) expr -> expr . NEQ expr
    (40) expr -> expr . LT expr
    (41) expr -> expr . GT expr
    (42) expr -> expr . AND expr
    (43) expr -> expr . OR expr

    SEMI            reduce using rule 43 (expr -> expr OR expr .)
    OR              reduce using rule 43 (expr -> expr OR expr .)
    COMMA           reduce using rule 43 (expr -> expr OR expr .)
    RPAREN          reduce using rule 43 (expr -> expr OR expr .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    EQ              shift and go to state 55
    NEQ             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    AND             shift and go to state 59

  ! PLUS            [ reduce using rule 43 (expr -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 43 (expr -> expr OR expr .) ]
  ! TIMES           [ reduce using rule 43 (expr -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 43 (expr -> expr OR expr .) ]
  ! EQ              [ reduce using rule 43 (expr -> expr OR expr .) ]
  ! NEQ             [ reduce using rule 43 (expr -> expr OR expr .) ]
  ! LT              [ reduce using rule 43 (expr -> expr OR expr .) ]
  ! GT              [ reduce using rule 43 (expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 43 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 60 ]


state 85

    (44) expr -> LPAREN expr RPAREN .

    SEMI            reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    EQ              reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    NEQ             reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 44 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 44 (expr -> LPAREN expr RPAREN .)


state 86

    (20) func_call -> ID LPAREN args RPAREN SEMI .

    INT             reduce using rule 20 (func_call -> ID LPAREN args RPAREN SEMI .)
    STRING_TYPE     reduce using rule 20 (func_call -> ID LPAREN args RPAREN SEMI .)
    BOOL_TYPE       reduce using rule 20 (func_call -> ID LPAREN args RPAREN SEMI .)
    ID              reduce using rule 20 (func_call -> ID LPAREN args RPAREN SEMI .)
    IF              reduce using rule 20 (func_call -> ID LPAREN args RPAREN SEMI .)
    WHILE           reduce using rule 20 (func_call -> ID LPAREN args RPAREN SEMI .)
    PRINT           reduce using rule 20 (func_call -> ID LPAREN args RPAREN SEMI .)
    RETURN          reduce using rule 20 (func_call -> ID LPAREN args RPAREN SEMI .)
    $end            reduce using rule 20 (func_call -> ID LPAREN args RPAREN SEMI .)
    RBRACE          reduce using rule 20 (func_call -> ID LPAREN args RPAREN SEMI .)


state 87

    (24) args -> expr COMMA args .

    RPAREN          reduce using rule 24 (args -> expr COMMA args .)


state 88

    (16) if_stmt -> IF LPAREN expr RPAREN block .
    (17) if_stmt -> IF LPAREN expr RPAREN block . ELSE block

    INT             reduce using rule 16 (if_stmt -> IF LPAREN expr RPAREN block .)
    STRING_TYPE     reduce using rule 16 (if_stmt -> IF LPAREN expr RPAREN block .)
    BOOL_TYPE       reduce using rule 16 (if_stmt -> IF LPAREN expr RPAREN block .)
    ID              reduce using rule 16 (if_stmt -> IF LPAREN expr RPAREN block .)
    IF              reduce using rule 16 (if_stmt -> IF LPAREN expr RPAREN block .)
    WHILE           reduce using rule 16 (if_stmt -> IF LPAREN expr RPAREN block .)
    PRINT           reduce using rule 16 (if_stmt -> IF LPAREN expr RPAREN block .)
    RETURN          reduce using rule 16 (if_stmt -> IF LPAREN expr RPAREN block .)
    $end            reduce using rule 16 (if_stmt -> IF LPAREN expr RPAREN block .)
    RBRACE          reduce using rule 16 (if_stmt -> IF LPAREN expr RPAREN block .)
    ELSE            shift and go to state 95


state 89

    (23) block -> LBRACE . stmt_list RBRACE
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . var_decl
    (5) stmt -> . assign_stmt
    (6) stmt -> . if_stmt
    (7) stmt -> . while_stmt
    (8) stmt -> . print_stmt
    (9) stmt -> . func_call
    (10) stmt -> . func_decl
    (11) stmt -> . return_stmt
    (50) empty -> .
    (12) var_decl -> . INT ID SEMI
    (13) var_decl -> . STRING_TYPE ID SEMI
    (14) var_decl -> . BOOL_TYPE ID SEMI
    (15) assign_stmt -> . ID EQUALS expr SEMI
    (16) if_stmt -> . IF LPAREN expr RPAREN block
    (17) if_stmt -> . IF LPAREN expr RPAREN block ELSE block
    (18) while_stmt -> . WHILE LPAREN expr RPAREN block
    (19) print_stmt -> . PRINT LPAREN expr RPAREN SEMI
    (20) func_call -> . ID LPAREN args RPAREN SEMI
    (21) func_decl -> . type ID LPAREN params RPAREN block
    (22) return_stmt -> . RETURN expr SEMI
    (31) type -> . INT
    (32) type -> . STRING_TYPE
    (33) type -> . BOOL_TYPE

    RBRACE          reduce using rule 50 (empty -> .)
    INT             shift and go to state 13
    STRING_TYPE     shift and go to state 15
    BOOL_TYPE       shift and go to state 16
    ID              shift and go to state 14
    IF              shift and go to state 17
    WHILE           shift and go to state 18
    PRINT           shift and go to state 19
    RETURN          shift and go to state 21

    stmt_list                      shift and go to state 96
    stmt                           shift and go to state 3
    empty                          shift and go to state 4
    var_decl                       shift and go to state 5
    assign_stmt                    shift and go to state 6
    if_stmt                        shift and go to state 7
    while_stmt                     shift and go to state 8
    print_stmt                     shift and go to state 9
    func_call                      shift and go to state 10
    func_decl                      shift and go to state 11
    return_stmt                    shift and go to state 12
    type                           shift and go to state 20

state 90

    (18) while_stmt -> WHILE LPAREN expr RPAREN block .

    INT             reduce using rule 18 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    STRING_TYPE     reduce using rule 18 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    BOOL_TYPE       reduce using rule 18 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    ID              reduce using rule 18 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    IF              reduce using rule 18 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    WHILE           reduce using rule 18 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    PRINT           reduce using rule 18 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    RETURN          reduce using rule 18 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    $end            reduce using rule 18 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    RBRACE          reduce using rule 18 (while_stmt -> WHILE LPAREN expr RPAREN block .)


state 91

    (19) print_stmt -> PRINT LPAREN expr RPAREN SEMI .

    INT             reduce using rule 19 (print_stmt -> PRINT LPAREN expr RPAREN SEMI .)
    STRING_TYPE     reduce using rule 19 (print_stmt -> PRINT LPAREN expr RPAREN SEMI .)
    BOOL_TYPE       reduce using rule 19 (print_stmt -> PRINT LPAREN expr RPAREN SEMI .)
    ID              reduce using rule 19 (print_stmt -> PRINT LPAREN expr RPAREN SEMI .)
    IF              reduce using rule 19 (print_stmt -> PRINT LPAREN expr RPAREN SEMI .)
    WHILE           reduce using rule 19 (print_stmt -> PRINT LPAREN expr RPAREN SEMI .)
    PRINT           reduce using rule 19 (print_stmt -> PRINT LPAREN expr RPAREN SEMI .)
    RETURN          reduce using rule 19 (print_stmt -> PRINT LPAREN expr RPAREN SEMI .)
    $end            reduce using rule 19 (print_stmt -> PRINT LPAREN expr RPAREN SEMI .)
    RBRACE          reduce using rule 19 (print_stmt -> PRINT LPAREN expr RPAREN SEMI .)


state 92

    (30) param -> type ID .

    COMMA           reduce using rule 30 (param -> type ID .)
    RPAREN          reduce using rule 30 (param -> type ID .)


state 93

    (21) func_decl -> type ID LPAREN params RPAREN . block
    (23) block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 89

    block                          shift and go to state 97

state 94

    (27) params -> param COMMA . params
    (27) params -> . param COMMA params
    (28) params -> . param
    (29) params -> . empty
    (30) param -> . type ID
    (50) empty -> .
    (31) type -> . INT
    (32) type -> . STRING_TYPE
    (33) type -> . BOOL_TYPE

    RPAREN          reduce using rule 50 (empty -> .)
    INT             shift and go to state 72
    STRING_TYPE     shift and go to state 73
    BOOL_TYPE       shift and go to state 74

    param                          shift and go to state 70
    params                         shift and go to state 98
    empty                          shift and go to state 71
    type                           shift and go to state 68

state 95

    (17) if_stmt -> IF LPAREN expr RPAREN block ELSE . block
    (23) block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 89

    block                          shift and go to state 99

state 96

    (23) block -> LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 100


state 97

    (21) func_decl -> type ID LPAREN params RPAREN block .

    INT             reduce using rule 21 (func_decl -> type ID LPAREN params RPAREN block .)
    STRING_TYPE     reduce using rule 21 (func_decl -> type ID LPAREN params RPAREN block .)
    BOOL_TYPE       reduce using rule 21 (func_decl -> type ID LPAREN params RPAREN block .)
    ID              reduce using rule 21 (func_decl -> type ID LPAREN params RPAREN block .)
    IF              reduce using rule 21 (func_decl -> type ID LPAREN params RPAREN block .)
    WHILE           reduce using rule 21 (func_decl -> type ID LPAREN params RPAREN block .)
    PRINT           reduce using rule 21 (func_decl -> type ID LPAREN params RPAREN block .)
    RETURN          reduce using rule 21 (func_decl -> type ID LPAREN params RPAREN block .)
    $end            reduce using rule 21 (func_decl -> type ID LPAREN params RPAREN block .)
    RBRACE          reduce using rule 21 (func_decl -> type ID LPAREN params RPAREN block .)


state 98

    (27) params -> param COMMA params .

    RPAREN          reduce using rule 27 (params -> param COMMA params .)


state 99

    (17) if_stmt -> IF LPAREN expr RPAREN block ELSE block .

    INT             reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN block ELSE block .)
    STRING_TYPE     reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN block ELSE block .)
    BOOL_TYPE       reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN block ELSE block .)
    ID              reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN block ELSE block .)
    IF              reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN block ELSE block .)
    WHILE           reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN block ELSE block .)
    PRINT           reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN block ELSE block .)
    RETURN          reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN block ELSE block .)
    $end            reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN block ELSE block .)
    RBRACE          reduce using rule 17 (if_stmt -> IF LPAREN expr RPAREN block ELSE block .)


state 100

    (23) block -> LBRACE stmt_list RBRACE .

    ELSE            reduce using rule 23 (block -> LBRACE stmt_list RBRACE .)
    INT             reduce using rule 23 (block -> LBRACE stmt_list RBRACE .)
    STRING_TYPE     reduce using rule 23 (block -> LBRACE stmt_list RBRACE .)
    BOOL_TYPE       reduce using rule 23 (block -> LBRACE stmt_list RBRACE .)
    ID              reduce using rule 23 (block -> LBRACE stmt_list RBRACE .)
    IF              reduce using rule 23 (block -> LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 23 (block -> LBRACE stmt_list RBRACE .)
    PRINT           reduce using rule 23 (block -> LBRACE stmt_list RBRACE .)
    RETURN          reduce using rule 23 (block -> LBRACE stmt_list RBRACE .)
    $end            reduce using rule 23 (block -> LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 23 (block -> LBRACE stmt_list RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 13 resolved as shift
WARNING: shift/reduce conflict for ID in state 15 resolved as shift
WARNING: shift/reduce conflict for ID in state 16 resolved as shift
